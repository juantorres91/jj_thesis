from pyomo.environ import *
from Tesis.initial import*
import Tesis.Molecular 

#****************************************************************************************************************************************
#----------------------------------------------------------------------------------------------------------------------------------------
#Mass- Molar and Volumetric Balances
#----------------------------------------------------------------------------------------------------------------------------------------
#****************************************************************************************************************************************

m=AbstractModel()

#Sets
m.Surf=Set()        #Surfactant set
m.Hum=Set()                 #Humectant set
m.Oils=Set()                #Multiple oil set
m.Comp=Set(initialize=[])   #All component set

def TotalSet(m):
    for i in m.Surf:
        m.Comp.add(i)
    for i in m.Hum:
        m.Comp.add(i)
    for i in m.Oils:
        m.Comp.add(i)
    m.Comp.add('Wat')
    
m.BuildComp=BuildAction(rule=TotalSet)

#Fases set
m.Fases=Set(initialize={'Cont','Dis'})  #Fase Set
m.FaCom=Set(dimen=2)

def Fases(m):
    for i in m.Comp:
        if i in m.Hum or i=='Wat':
            m.FaCom.add(('Cont',i))
        elif i in m.Oils:
            m.FaCom.add(('Dis',i))
m.BuildFases=BuildAction(rule=Fases)


#Parameters

m.TMass=Param(default=100)     #Total mass
m.Rho=Param(m.Comp, default=1) #Mass Density

#Variables

m.mass= Var(m.Comp, within=NonNegativeReals, bounds=(0,100), initialize=1 )  #Mass [g] / 100 [g] of product
m.vol=  Var(m.Comp, within=NonNegativeReals, bounds=(0,200), initialize=10)   #Volumetric basis  [cm3]
m.vtot= Var(within=NonNegativeReals, initialize=100)                          #Total Volume      [cm3]

m.x_m=Var(m.Comp, bounds=(0,1), initialize=0.1)        # Mass   Percentage
m.x_v=Var(m.Comp, bounds=(0,1), initialize=0.1)        # Volume Percentage

#Constraints

def xm_def(m,i):                             #Mass Fraction Definition
    return m.x_m[i]==m.mass[i]/m.TMass
m.xm_def=Constraint(m.Comp, rule=xm_def)

def xv_def(m,i):                             #Volume Fraction Definition
    return m.x_v[i]==m.vol[i]/m.vtot
m.xv_def=Constraint(m.Comp, rule=xv_def)

def MassBalance(m):                          #Mass Conservation
    return summation(m.mass)==m.TMass
m.MassBalance=Constraint(rule=MassBalance)

def VolBalance(m):
    return summation(m.vol)==m.vtot          #Volume conservation
m.VolBalance=Constraint(rule=VolBalance) 

def Vol_Def(m, j):                           #Volume definition
    return m.vol[j]==m.mass[j]/m.Rho[j]
m.Vol_Def=Constraint(m.Comp, rule=Vol_Def)

#Fases balance---------------------------------------------

m.ft_m=Var(m.Fases, domain=PositiveReals)           #Fases Total Mass [g]
m.pa_x=Var(m.Fases, m.Comp, domain=PositiveReals)   #Fases Partial mass fraction [-]

m.ft_v=Var(m.Fases, domain=PositiveReals, initialize=50)          #Fases Total volume [cm3]
m.f_rho=Var(m.Fases, domain=PositiveReals, initialize=1)          #Fases density      [g/cm2]

def ftotal_mass(m,i):                               #Fases Total mass definition   [g]
    return m.ft_m[i]==sum(m.mass[j] for j in m.Comp if (i,j) in m.FaCom)
m.ftotal_mass=Constraint(m.Fases, rule=ftotal_mass)

def fmass_def(m,i,j):  #Fases mass fraction definition
    if (i,j) in m.FaCom:
        return m.pa_x[i,j]==m.mass[j]/m.ft_m[i]
    else:
        return Constraint.Skip
m.fmass_def=Constraint(m.Fases, m.Comp, rule=fmass_def)

def ftotal_vol(m,i):                                 #Fases Total volume definition
    return m.ft_v[i]==sum(m.vol[j] for j in m.Comp if (i,j) in m.FaCom)
m.ftotal_vol=Constraint(m.Fases, rule=ftotal_vol)

def f_rhodef(m,i):                                      #Fases density [g/cm3]
    return m.f_rho[i]==m.ft_m[i]/m.ft_v[i]
m.f_rhodef=Constraint(m.Fases, rule=f_rhodef)


#****************************************************************************************************************************************
#----------------------------------------------------------------------------------------------------------------------------------------y
#Macroscopic Properties Constrains
#----------------------------------------------------------------------------------------------------------------------------------------
#****************************************************************************************************************************************

#Sets
m.MacroP=Set()           #Macroscopic Properties set
m.Cuts=RangeSet(1,6)     #Cutting planes set

#Parameters
m.m1=Param(m.MacroP, m.Cuts,default=0) #Cutting Plane Slope
m.b1=Param(m.MacroP, m.Cuts,default=0) #Cutting Plane intersect

#Variables
m.c_y=Var(m.MacroP, initialize=100, bounds=(0,100))            #Customer Preference over particular propertie
m.c_x=Var(m.MacroP, initialize=50)                             #Property assorted variable

#------------------------------------
#Effectivness

m.Hmol=Var(m.Hum, domain=PositiveReals, initialize=10)         # Humectant Nanomol/cm2
m.MW=Param(m.Hum,  default=1)                                  #Molecular weight - Humectact

def Nanoc2(m, i):                                              #Humectanct calculation
    return m.Hmol[i]==2*1e4* m.mass[i]/m.MW[i]
m.Nanoc2=Constraint(m.Hum, rule=Nanoc2)

#------------------------------------
#Viscocity modules

#Parameters
m.Visco=Param(m.Comp, default=1)                                #25C dynamic viscocity [cP]
def VBN_def(m,i):
    if i not in m.Surf:
        return 14.534*log( log( m.Visco[i]+0.8) ) +10.975
m.VBN=Param(m.Comp, initialize=VBN_def)                         #Viscocity blending number [-]
m.gma0=Param(initialize=52.55)                                  #Interface initial tension

#Variables
m.VBNb=Var(m.Fases, initialize=1)                             #Blend VBN [-]
m.kmu=Var(m.Fases, domain=PositiveReals, initialize=1)          #Fase kinematic viscosity [cst]
m.dmu=Var(m.Fases, domain=PositiveReals, initialize=1)          #Fases dynamic viscosity  [P]
m.e_mu=Var(domain=PositiveReals, initialize=100)                 #Emulsion dynamic viscosity [P]

m.v_frac=Var(domain=PositiveReals, initialize=1)              #Volume fraction
m.kappa=Var(domain=PositiveReals, initialize=1)                 #Viscosity ratio

m.l1=Var(initialize=1)                    #Pal- Parameter 1
m.l2=Var(initialize=1)                    #Pal- Paramerter 2 
m.yp1=Var(initialize=10)                   #Pal- Fragment 1
m.yp2=Var(initialize=10)                   #Pal- Fragment2


m.Nca=Var(domain=PositiveReals, initialize=100)                        #Capilarity Number
m.Gamma=Var(domain=PositiveReals, bounds=(1e2,1e6))    #Process Shear rate [s^-1]
m.drop=Var(domain=PositiveReals, initialize=20)                       #Dropplet mean size[10^-6 m]
m.STen=Var(domain=PositiveReals, initialize=3)                       #Surface Tension [10^-3 N/m]


#Constraints
def VBMb_def(m,i): #Fases Constraint Definition
   return  m.VBNb[i]== sum( m.VBN[j]*m.pa_x[i,j] for j in m.Comp if (i,j) in m.FaCom)
m.VBMb_def=Constraint(m.Fases, rule=VBMb_def)

def kmu_def(m,i): #Fases kinematic viscosity definition
    return m.kmu[i]==exp( exp( ( m.VBNb[i]-10.975)/14.534) ) -0.8
m.kmu_def=Constraint(m.Fases, rule=kmu_def)

def dmu_def(m,i): # Fases dynamic viscosity definition
    return m.dmu[i]==m.kmu[i]*m.f_rho[i]/100
m.dmu_def=Constraint(m.Fases, rule=dmu_def)

def vfrac_def(m): #Volume ratio
    return m.v_frac==m.ft_v['Dis']/m.vtot
m.vfrac_def=Constraint(rule=vfrac_def)

def kratio_def(m): #Viscocity ratio
    return m.kappa==m.dmu['Dis']/m.dmu['Cont']
m.kratio_def=Constraint(rule=kratio_def)

def lam_1(m): #L1 definition
    return m.l1==(19*m.kappa+16)*(2*m.kappa+3)/(40*(m.kappa+1))*(1+(19*m.kappa+16)*m.v_frac/(5*(m.kappa+1)*(2*m.kappa+3)))
m.lam_1=Constraint(rule=lam_1)

def lam_2(m): #L2 definition
    return m.l2==(19*m.kappa+16)*(2*m.kappa+3)/(40*(m.kappa+1))*(1-3*(19*m.kappa+16)*m.v_frac/(10*(m.kappa+1)*(2*m.kappa+3)))
m.lam_2=Constraint(rule=lam_2)

# Yaron- Pal equation
def Pal_1(m):
    return m.yp1==(1+(5*m.kappa+1)*m.v_frac/(2*(m.kappa+1))+(5*m.kappa+1)**2*m.v_frac**2/(10*(m.kappa+1)**2))
m.Pal_1=Constraint(rule=Pal_1)

#Yaron Pal 2
def Pal_2(m):
    return m.yp2==(1+m.l1*m.l2*m.Nca**2)/(1+m.l1**2*m.Nca**2)
m.Pal_2=Constraint(rule=Pal_2)

#Yaron Pal complete
def Pal_eq(m):
    return m.e_mu==m.dmu['Cont']*m.yp1*m.yp2
m.Pal_eq=Constraint(rule=Pal_eq)

#Capilarity definition
def cap_def(m):
    return m.Nca==1e-4*m.e_mu*m.Gamma*m.drop/(2*m.STen)
m.cap_def=Constraint(rule=cap_def)

#Interface tension def:
def IN_Def(m):
    return m.STen==m.gma0-m.y_prop[1,'STR']
m.IN_Def=Constraint(rule=IN_Def)

#Constraints---------------------------------------------------------------------------------------------------------------------------
def Assorted(m,i):                                            #Assorted property variable
    if i=='Fat':
        return m.c_x[i]==sum(m.mass[j] for j in m.Oils)+m.mass['Glyce']
    if i=='Efec':
        return m.c_x[i]==summation(m.Hmol)
    if i=='Thic':
        return m.c_x[i]==m.e_mu**0.5
    else:
        return Constraint.Skip
m.Assorted=Constraint(m.MacroP, rule=Assorted)

def Cutting(m,i,j):                          #Property cutting place approximation
    if m.m1[i,j]!=0 and m.b1[i,j]!=0:
        return m.c_y[i]<=m.m1[i,j]*m.c_x[i]+m.b1[i,j]
    else:
        return Constraint.Skip
m.Cutting=Constraint(m.MacroP, m.Cuts, rule=Cutting)

#************************************************************************************************************
#----------------------------------------------
#Objective
#---------------------------------------------
#************************************************************************************************************
m.w_c=Param(m.MacroP, default=0, mutable=False)  #Poderation weights


def ObjRule(m):
    return summation(m.w_c,m.c_y)

m.Obj=Objective(sense=maximize, rule=ObjRule )

